// ------------ math.asa ------------
// Contains functions for doing math
import "logical.asa";

// modulo: computes the smallest positive representation of a mod b
begin modulo:
  pop b; pop a;
  push a; push 0; cmp; pop a_to_0;

  push a_to_0; ifgoto 0 rem_0;        // if a == 0, jump to rem_0
  push a_to_0; ifgoto 1 a_greater_0;  // if a  > 0, jump to a_greater_0
  // else: here means a < 0 (negativ)
  // => add b to a until a >= 0
  label a_lesser_0;
    push a; push b; add; pop a;
    push a; push 0; cmp; pop a_to_0;
  push a_to_0; ifgoto -1 a_lesser_0;

  // If a > 0, jump to a_greater_0
  push a; push 0; cmp; pop a_to_0;
  push a_to_0; ifgoto 1 a_greater_0;

  // If a == 0
  // or a == b
  // push 0 to rem and return
  label rem_0;
    push 0; pop rem; goto return;

  // If a > 0, compare a with b
  label a_greater_0;
    push a; push b; cmp; pop a_to_b;
    push a_to_b; ifgoto -1 a_lesser_b; // if a  < b, jump to a_lesser_b
    push a_to_b; ifgoto 0 rem_0;       // if a == b, jump to rem_0

    // If a > b, subtract b from a until a < b
    label a_greater_b;
      push a; push b; sub; pop a;
      push a; push b; cmp; pop a_to_b;
    push a_to_b; ifgoto 1 a_greater_b;
    push a_to_b; ifgoto -1 a_lesser_b;
    goto rem_0;                        // because at this point a == b

  // If a < b, set remainder to a and return
  label a_lesser_b;
    push a; pop rem; goto return;

  label return;
    push rem;
end

// max: returns the maximum of two values
begin max:
  pop a; pop b;
  push a; push b; call logical/lesser_or_eq?; pop a_leq_b;
  push a_leq_b; call logical/not; pop b_gt_a;
  push a; push b_gt_a; mul;  // a * (b > a)
  push b; push a_leq_b; mul; // b * (a <= b)
  add;                       // (a * (b > a)) + (b * (a <= b))
end

// min: returns the minimum of two values
begin min:
  pop a; pop b;
  push a; push b; call logical/lesser_or_eq?; pop a_leq_b;
  push a_leq_b; call logical/not; pop b_gt_a;
  push a; push a_leq_b; mul;  // a * (a <= b)
  push b; push b_gt_a; mul;   // b * (b > a)
  add;                        // (a * (a <= b)) + (b * (b > a))
end

// power: pushes the result of a to the power of b to the stack
begin power:
  pop b; pop a;
  push 1; pop res;                         // initialize res to 1
  label loop;
    push b; push 0; cmp; ifgoto 0 return;  // if b is 0 return res
    push res; push a; mul; pop res;        // res = res * a
    decr b;                                // decrement b
    goto loop;                             // repeat...
  label return; push res;
end

// abs: pushes the absolute value of the element on top of the stack
begin abs:
  pop n;
  push n; push 0; cmp; ifgoto -1 negative;        // if n < 0 return -1 * n
  push n; pop res; goto return;                   // else     return n
  label negative; push n; push -1; mul; pop res;
  label return; push res;
end

// even?: pushes 1 to the stack if the number is even
begin even?:
  pop n; push n; push 2; call math/modulo;
  push 0; call logical/equals?;
end

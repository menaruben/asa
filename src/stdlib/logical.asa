// ------------ logical.asa ------------
// Contains functions to simplify conditions.
// These are *not* bitwise operations but logical, meaning that they work with 0 (False) and 1 (True)
// However, if you wish to find the bitwise operations you can find them in bitwise.asa

// eq? pushes 1 to stack if the values on top of the stack are equal, 0 otherwise
begin eq?:
  pop a; pop b;
  push a; push b; cmp; pop comparison;
  push comparison; ifgoto -1 a_neq_b;  // if a  < b return 0
  push comparison; ifgoto 1 a_neq_b;   // if a  > b return 0
  push 1; pop res; goto return;        // if a == b return 1
  label a_neq_b; push 0; pop res;
  label return;  push res;
end

// neq? pushes 1 to stack if the values on top of the stack are not equal, 0 otherwise
begin neq?:
  pop a; pop b;
  push a; push b; call eq?; ifgoto 0 not_equal; // if a != b return 1
  push 0; pop res; goto return;                 // if a == b return 0
  label not_equal; push 1; pop res;
  label return;    push res;
end

// not negates the top of the stack (0 (and all non-zero) to 1, 1 to 0) and pushes it to the stack
begin not:
  pop a;
  push a; push 1; call eq?; ifgoto 1 one_to_zero;  // if a == 1 return 0
  push 1; pop res; goto return;                    // else return 1
  label one_to_zero; push 0; pop res;
  label return;      push res;
end

// or? pushes 1 to the stack if one of the two elements on top of the stack is 1, 0 otherwise
begin or?:
  pop a; pop b;
  push a; push 1;  call eq?; ifgoto 0 b_cmp;        // if a != 1 try b comparison
  push 1; pop res; goto return;                     // else return 1
  label b_cmp;
    push b; push 1; call eq?; ifgoto 0 or_false;    // if b != 1 return 0
    push 1; pop res; goto return;                   // else return 1
    
  label or_false; push 0; pop res;
  label return;   push res;
end

// and? pushes 1 to the stack if both two elements on top of the stack are 1, 0 otherwise
begin and?:
  pop a; pop b;
  push a; push 1; call eq?; ifgoto 0 and_false;  // if a != 1 return 0
  push a; push b; call eq?; ifgoto 0 and_false;  // if a != b return 0
  push 1; pop res; goto return;                  // else return 1
  label and_false; push 0; pop res;
  label return;    push res;
end

// xor? pushes 1 to the stack if only one of the two elements on top of the stack is 1, 0 otherwise
begin xor?:
  pop a; pop b;
  push a; push b; call and?; ifgoto 1 xor_false;  // if a and b      return 0
  push a; push b; call or?;  ifgoto 0 xor_false;  // if not (a or b) return 0 
  push 1; pop res; goto return;                   // else return 1
  label xor_false; push 0; pop res; goto return;
  label return;    push res;
end
